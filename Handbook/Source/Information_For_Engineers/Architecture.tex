% This is part of the Avaneya Project Crew Handbook.
% Copyright (C) 2010, 2011
%   Kshatra Corp.
% See the file License for copying conditions.

% AresEngine architectural design...
\StartSection{Architecture}

The AresEngine is responsible for delivering Avaneya, the mod. It is designed by the Avaneya Project Crew to provide for the game, but kept architecturally general enough to lend itself to other projects of similar technical requirements (e.g. a city builder / real time strategy genre). If you do not know what a game engine is, Jason Gregory's book {\it Game Engine Programming},\footnote{See \in{section}[Resources For Engineers] for details on this book.} is highly recommended.

The AresEngine is divided up into many subsystems, each responsible for a given logical task. These include audio, responding to input devices, updating the graphical user interface, artificial intelligence, and so on.

Umbrello was used to come up with the architectural design. At this time, you may need to use the latest Umbrello built from source because the task at hand was so demanding, only Umbrello's bleeding edge was able to handle it. Unfortunately the pre-compiled binary available in most distributions had many show stopper bugs in it that would have have made work impossible. Even building from source, it still has many problems. Nevertheless, it was the most mature and functional free design tool available at the time and may still be. We are very grateful to the Umbrello crew who were especially helpful in fixing bugs as they were discovered through the engine design stress testing it.

The following architectural diagrams were pulled from the AresEngine's Umbrello project file automatically at the time this handbook was compiled on \currentdate\ from Bazaar revision \BazaarRevision, and using \cldcontext{os.resultof"umbrello --version | grep -i umbrello | tr -d ':\\n'"}.

% Engine subsection...
\StartSubSection{Engine}
This diagram captures the engine at the highest level and provides an overview of all components in an abstract sense.

\FullPageLandscapeDiagram
    {EngineUML}
    {The AresEngine high level overview.}
    {Source/Information_For_Engineers/Images/AresEngine/Engine.svg}

% Artificial intelligence subsection...
\StartSubSection{Artificial Intelligence}
This diagram concerns itself with useful artificial intelligence algorithms, though not of an entire subsystem itself.

It contains an implementation of the A* search strategy algorithm.\footnote{See {\it Computational Intelligence: A Logical Approach}, Poole et al., 1998 for an explanation on the algorithm.} The problem here is represented as a pattern for an abstract base class called {\tt AStarBase}. The {\it h(x)} heuristic function is implemented via an override a context specific superclass. The abstract base class is deliberately kept general so as to not be limited to searching for a solution in a spatial sense, but in any representable solution space (e.g. time, language, etc.).

\FullPageLandscapeDiagram
    {ArtificialIntelligenceUML}
    {Engine's artificial intelligence facilities.}
    {Source/Information_For_Engineers/Images/AresEngine/Artificial Intelligence.svg}

% Audio subsection...
\page
\StartSubSection{Audio}
The {\tt AudioManager} subsystem is responsible for all tasks related to audio. Audio playback is divided into streaming and static audio sources. Streaming sources need to be continuously updated by loading new data from disk, decompressing it, and playing it. A common example would be music or narrative. Static sources are usually smaller and only need to played once before being freed. Static source examples would be things like the sound of an object contacting another.

Decoding is done through an appropriate subclass of an {\tt Ares::AudioDecoderBase} abstract class, instantiated via the {\tt Ares::AudioDecoderFactory} class. Most decoding is done through a subclass of the aforementioned via {\tt SDL_audio}.

Playback is accomplished through OpenAL.

\FullPageLandscapeDiagram
    {AudioUML}
    {The audio subsystem.}
    {Source/Information_For_Engineers/Images/AresEngine/Audio.svg}

% Configuration subsection...
\page
\StartSubSection{Configuration}
The {\tt ConfigurationManager} subsystem is responsible for storing all user configuration. Its {\tt Load()} method reads all configuration variables from disk, and then adds variables from command line as well, in that order. 

Latter configuration variables read are set as non-archivable. A non-archivable configuration variable is one that is not saved to disk.

Much of the manager is implemented in Lua because of its excellent database handling.

\FullPageLandscapeDiagram
    {ConfigurationUML}
    {The configuration subsystem.}
    {Source/Information_For_Engineers/Images/AresEngine/Configuration.svg}

% Console subsection...
\page
\StartSubSection{Console}
The in game console allows users to access aspects of the game engine at runtime. This is useful for debugging or other purposes.

Console commands are implemented in Lua.

\FullPageLandscapeDiagram
    {ConsoleUML}
    {The console subsystem.}
    {Source/Information_For_Engineers/Images/AresEngine/Console.svg}

% Design patterns subsection...
\page
\StartSubSection{Design Patterns}
This diagram contains a number of common place design patterns found in many software projects, such as the singleton and multi-factory. 

There seems to be two kinds of singleton design patterns in the literature that are not distinguished, but should be. There is the kind whose instantiation is implicit, meaning you don't care when it is created, just as long as it is there when you need it and that there is only at most one of them ever at a given time. We refer to this as the {\it implicit singleton} and it typically uses lazy instantiation.

The second kind, like the first, only ever has one instance, but you control when you want it instantiated and deconstructed explicitly. We refer to this as the {\it explicit singleton}. This is useful for engine subsystems since C++ does not define the order in which constructors for global objects are invoked across translation units. This is important to consider, given that the order of subsystem initialization is very important (e.g. resource management must precede audio management).

\FullPageLandscapeDiagram
    {DesignPatternsUML}
    {Useful design patterns.}
    {Source/Information_For_Engineers/Images/AresEngine/Design Patterns.svg}

% subsection...
\page 
\StartSubSection{Events}
The {\it EventManager} is responsible for intercommunication between various engine components and scripts. The steps for working with events are as follows.

An event handler can either contain an {\it Ares::EventHandler} class, or can derive from it and override the {\tt OnEvent()} method. It registers interest in one or more events via the {\tt Register()} method:

\startCodeExample
EventHandler::Register("some_event");
\stopCodeExample

Next, to create and enqueue an event, one would do as follows:
\startCodeExample
\starttyping
// Create a some_event event...
Ares::Event SomeEvent("some_event");

// Enqueue event...
Ares::EventManager::GetSingleton().Enqueue(SomeEvent);
\stoptyping
\stopCodeExample

Every frame, the {\tt EventManager::DispatchEvents()} method is called to pump the message queue. It will get an event from the internal priority queue that is due for processing. Once an event is fetched, it calls {\tt Event.Dispatch()} to pass it to all registered handlers so that they may do whatever it is that they would like to do when that event occurs.

Events.xsd defines the XML schema that the engine uses at runtime to check builtin event types (Events.xml) against. This is done to ensure the event types defined are syntactically correct and self documenting.

Events.xml contains a list of built-in event types, game engine mod agnostic, for fundamental event types. These include things like input device and window manager events.

\FullPageLandscapeDiagram
    {EventUML}
    {The event subsystem.}
    {Source/Information_For_Engineers/Images/AresEngine/Events.svg}

% subsection...
\page 
\StartSubSection{File System}
Accessing files on disk for textures, shaders, scripts, models, sounds, and so on, requires an intermediary in most game engines. The AresEngine is no different. Files are stored inside of an EBML encoded container format called an AresPackage. You can read more about it in \in{section}[AresPackages]. The EBML format was selected because it enables extendability for future format changes and allows arbitrary metadata. 

It also has performance advantages because only a single file (*.AresPackage) needs to be located for a group of files contained within it. This reduces file seek and access times. This is further enhanced with the fact that the AresPackage files can be compressed. Accessing a single AresPackage file containing many compressed files means that the engine will take less time to access its payload since transferring a single small file from disk and decompressing it in RAM to unpack many files is much faster than transferring a single large or multitude of uncompressed files from disk to RAM. The CPU is fast because it is purely electronic. The hard drive and optical media are slow because they are electromechanical and must wait for the disk to spin to the right location before it can read, which is, on average, half the worst case seek time.

\FullPageLandscapeDiagram
    {FileSystemUML}
    {The file system subsystem.}
    {Source/Information_For_Engineers/Images/AresEngine/File System.svg}

% subsection...
\page 
\StartSubSection{Gooey}
The {\it GooeyManager} is responsible for managing all graphical user interface overlays and user interaction with them. Its underlying functionality is provided by CEGUI which integrates well into OGRE 3D.

{\tt GooeyManager::Initialize()} calls {\tt CEGUI::OgreRenderer::bootstrapSystem()}. This bootstraps {\tt CEGUI::System} with an {\tt OgreRenderer} object that uses the default Ogre rendering window as the default output surface, an Ogre based {\it ResourceProvider}, and an Ogre based {\it ImageCodec}.

{\tt Update()} is called every frame, but we do not need to call {\tt System::renderGUI()} since Ogre does this automatically. We do, however, need to call {\tt CEGUI::System::injectTimePulse()} within there.

{\tt Shutdown()} calls {\tt CEGUI::OgreRenderer::destroySystem()}.

Most of the interesting interfaces are within CEGUI singletons themselves, with appropriate accessors and mutators exported to Lua.

\FullPageLandscapeDiagram
    {GooeyUML}
    {The graphical user interface subsystem.}
    {Source/Information_For_Engineers/Images/AresEngine/Gooey.svg}

% subsection...
\page 
\StartSubSection{Human Interface}
The {\it HumanInterfaceManager} takes care of routing all events from input devices to the appropriate code that has registered to be notified of that event. In that sense, the manager is mostly unidirectional, but also allows to send information the other way back to the input device if it supports a haptic interface (sometimes called force feedback).

\FullPageLandscapeDiagram
    {HumanInterfaceUML}
    {The human interface subsystem.}
    {Source/Information_For_Engineers/Images/AresEngine/Human Interface.svg}

% subsection...
\page 
\StartSubSection{Logging & Error Control}
The {\tt LogManager} is responsible for providing a central logging subsystem for all the other subsystems.

\FullPageLandscapeDiagram
    {LoggingUML}
    {The logging and error control subsystem.}
    {Source/Information_For_Engineers/Images/AresEngine/Logging and Error Control.svg}
    
Since message can be emitted from any number of places, such as within the engine, or within some other externally linked component, such as CEGUI or OGRE, messages have to be intercepted and channeled through the {\tt LogManager}. The following diagram makes this more clear.

\FullPageLandscapeDiagram
    {LoggingStateUML}
    {The logging pipeline.}
    {Source/Information_For_Engineers/Images/AresEngine/Logging State Diagram.svg}

% subsection...
\page 
\StartSubSection{Mathematical}
Most mathematical routines for matrices and other linear algebra are provided by OGRE 3D. Some things like more advanced random number generation have to be implemented ourselves here.

\FullPageLandscapeDiagram
    {MathematicalUML}
    {Various mathematical facilities.}
    {Source/Information_For_Engineers/Images/AresEngine/Mathematical.svg}

% subsection...
\page 
\StartSubSection{Miscellaneous}
This is a catch-all for classes and functions that had no business elsewhere.

\FullPageLandscapeDiagram
    {MiscellaneousUML}
    {Miscellaneous engine components.}
    {Source/Information_For_Engineers/Images/AresEngine/Miscellaneous.svg}

% subsection...
\page 
\StartSubSection{Physics}
The {\tt PhysicsManager} needs to be seriously refactored since OgreBullet was found as a viable option for physics support. This is the original, incomplete, design before that decision was made.

\FullPageLandscapeDiagram
    {ScriptingUML}
    {The scripting subsystem.}
    {Source/Information_For_Engineers/Images/AresEngine/Physics.svg}

% subsection...
\page 
\StartSubSection{Resources}
The {\tt ResourceManager} is responsible for ensuring that whenever code needs a piece of game data, such as a model or animation, all of its requisites are loaded, in the correct order, only once, and take up only as much room as they absolutely must. The {\tt ResourceManager} and the {\tt FileManager} communicate to help the former locate what it needs physically on disk.

\FullPageLandscapeDiagram
    {ResourcesUML}
    {The resources subsystem.}
    {Source/Information_For_Engineers/Images/AresEngine/Resources.svg}

% subsection...
\page 
\StartSubSection{Scripting}
The {\tt ScriptManager} is responsible for exposing all useful aspects of the game engine to the game scripters. Since the engine itself is defined in code, the role of defining what makes Avaneya, Avaneya, is left to script writers.

\FullPageLandscapeDiagram
    {ScriptingUML}
    {The scripting subsystem.}
    {Source/Information_For_Engineers/Images/AresEngine/Scripting.svg}

