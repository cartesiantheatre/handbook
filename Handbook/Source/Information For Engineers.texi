@c Information For Engineers chapter...
@node Information For Engineers
@chapter Information For Engineers

@node Coding Standards
@section Coding Standards

Try to abide by the project coding standards whenever possible. It is easier to adapt to a new coding standard in a project when that standard is uniformly applied to it, as opposed to where everyone applies their own. Try to apply the following conventions whenever working in C++, as well as whatever is practical to carry over to shaders, scripts, and elsewhere.

@node Legal
@subsection Legal
Headers (*.h), implementations (*.cpp), and other code, as defined under @ref{Licensing Rationale}, should have prefixed the following legal notice. Adapt the syntax for comments as necessary for the given machine environment (e.g. shader, makefile, etc.).
@sp 1

@example
/*
    AresEngine, a 3D game engine.
    Copyright (C) 2011 Kshatra Corp <kip@@thevertigo.com>.

    Public discussion on IRC available at #avaneya (irc.freenode.net)
    or on the mailing list <avaneya@@lists.avaneya.com>.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
@end example

@node Formatting
@subsection Formatting
@sp 1

@itemize

@item
Always use spaces and not tabs.
@sp 1

@item
Each level of nesting should be indented by four spaces. The exception to this is when a prefix operator precedes an identifier, in which case it should be indented so that the identifier begins at a four space interval.
@sp 1

Right:
@example
float SomeFunction()
@{
    int i = 0;
  ++i;
    return 1.0f;
@}
@end example
@sp 1

Wrong:
@example
float SomeFunction()
@{
    int i = 0;
    ++i;
        return 1.0f;
@}
@end example
@sp 1

@item
You do not need to indent to accommodate a namespace when an entire source file is enclosed within one. If only part of the source is enclosed in a namespace, then those parts affected should be indented.
@sp 1

@item
An opening brace appears on the next line as preceding code.
@sp 1

Right:
@example
float SomeFunction()
@{
    for(int x = 0; x < 100; ++x)
    @{
        ...
    @}
@}
@end example
@sp 1

Wrong:
@example
float SomeFunction() @{
    for(int x = 0; x < 100; ++x) @{
        ...
    @}
@}
@end example
@sp 1

@item
Put spaces around binary operands
@sp 1

Right:
@example
A = X + Y;
if(X == Y)
    ...
@end example
@sp 1

Wrong:
@example
A = X+Y;
if(X==Y)
    ...
@end example
@sp 1

@item
There is no space between unary operators and the affected variable's name.
@sp 1

@item
When accessing an array, there is no space between the array name and the opening left bracket. 
@sp 1

Right:
@example
int n[100];
y = n[3];
@end example
@sp 1

Wrong:
@example
int n [100];
y = n [3];
@end example
@sp 1

@item
The if, for, and while keywords are not followed by a space separating them and the left parenthesis. 
@sp 1

Right:
@example
if(x == 4)
    return;
@end example
@sp 1

Wrong:
@example
if (x == 4)
    return;
@end example
@sp 1

@item
When declaring variables, align the variable names on the same column evenly divisible by four.
@sp 1

Right:
@example
int     Count;
bool    Complete;
Window  MainWindow;
@end example
@sp 1

Wrong:
@example
int Count;
bool Complete;
Window MainWindow;
@end example
@sp 1

@item
When calling a function, definitions and function declarations should have no space between the function name and the following left parenthesis.
@sp 1

Right:
@example
int Add(int a, int b)
@{ 
    ... 
@}
@sp 1

int i = Add(4, 5);
@end example
@sp 1

Wrong:
@example
int Add (int a, int b)
@{
    ...
@}
@sp 1

int i = Add (4, 5);
@end example
@sp 1

@item
When calling a function or making a function declaration, no space appears after the left parenthesis or before the right parenthesis.
@sp 1

Right:
@example
foo(x, y);
bar(z);
baz();
@end example
@sp 1

Wrong:
@example
foo( x, y );
bar( z );
baz( );
@end example
@sp 1

@item
A brace preceding or following an else keyword appears on the same line as the else. A statement following an else keyword appears on the same line as the else. 
@sp 1

Right:
@example
if(x == 4)
@{
    ...
@}
else
  ++y;

if(x == 4)
@{
    ...
@}
else
@{
    ...
@}
@end example
@sp 1

Wrong:
@example
if(x == 4) @{
    ...
@}
else ++y;

if(x == 4) @{
    ...
@} else ++y;

if(x == 4) @{
    ...
@}
else @{
    ...
@}
@end example
@sp 1

@item
A brace preceding a catch keyword appears on a separate line as the catch. 
@sp 1

Right:
@example
try
@{
    ...
@}

catch(Error SomeError)
@{
    ...
@}
@end example
@sp 1

@item
A value in a return statement is parenthesized where it contains more than one term.
@sp 1

Right:
@example
return x;
return (a + b);
@end example
@sp 1

Wrong:
@example
return (x);
return a + b;
@end example
@sp 1

@item
If the body of an if, for, while or similar statement consists of a single statement, the statement does not need to be surrounded by braces.
@sp 1

Right:
@example
if(x == 3)
  ++x;
@end example
@sp 1

@end itemize

@node Naming
@subsection Naming
@sp 1

@itemize
@item
Do not use Hungarian notation. We prefix objects to denote scope only.
@sp 1

Member of a global namespace:
@example
g_Wheels
@end example
@sp 1

Member of a structure or class:
@example
m_Wheels
@end example
@sp 1

Static member of a structure or class:
@example
ms_Wheels
@end example
@sp 1

@item
Class and object names should be intuitive, try to avoid abbreviations, and each word should begin with a capital letter. Modern storage mediums can afford to spare brevity, allowing for greater clarity.
@sp 1

Right:
@example
// Class for abstracting a camera interface...
class Camera
@{
    ...
@};

// Create a camera...
Camera LogitechCamera;
@end example

Wrong:
@example
class cam
@{
    ...
@};

cam log;
@end example

@end itemize

@node Structure
@subsection Structure
@sp 1
@itemize
@item
Source lines may be up to 100 characters long. (You can configure gedit to display a margin at 100 characters; that may help you follow this convention.)
@sp 1

@item
Functions or methods should be broken down into other functions or methods if they get too long and this is reasonable to do.
@sp 1

@item
Use @i{assert()} to check your assumptions for things that ought to always be true. Do not abuse it for situations where it is reasonable for a condition to not be true, such as a socket connection failure or a file that could not be opened.
@sp 1

@item
Follow the @i{GNU Coding Standards} as much as reasonably possible, save the code formatting points made in this handbook. There is a great deal of wisdom in it.
@sp 1

@item
A comment which indicates task which needs to be done at some point should look like this: 
@sp 1

@example
// TODO: Check portability here...
@end example
@sp 1

@end itemize

@node Comments
@subsection Comments
@sp 1

@itemize
@item
All comments should be written in English since nearly all programmers in all countries can read that. If you cannot do that, write them as best you can and have someone help you rewrite them.
@sp 1

@item
Comments should begin with a single space, then a capital letter and end with a trailing ellipses. 
@sp 1

Right:
@example
// Load the image...
GrayImage = cvLoadImage(Path.mb_str(), CV_LOAD_IMAGE_GRAYSCALE);
@end example
@sp 1

Wrong:
@example
GrayImage = cvLoadImage(Path.mb_str(), CV_LOAD_IMAGE_GRAYSCALE);//load the image.
@end example
@sp 1

@item
The farther left the comment, the higher level and abstract what you are trying to do is. The farther right, the more detailed they are. You can think of a given level of indentation as elaborating on how to carry out what was described at a higher (less indented) level. It should be possible in many cases to strip away all the code, except the comments, and still understand what it is that you were trying to do.
@sp 1

Before:
@example
// Analyze single image...
void AnalysisThread::AnalyzeImage(wxString Path)
@{
    // Variables...
    IplImage   *GrayImage   = NULL;
    wxString    TempString;

    // Reset the tracker, if not already...
    Frame.Tracker.Reset(0);

    // Load the image...
    GrayImage = cvLoadImage(Path.mb_str(), CV_LOAD_IMAGE_GRAYSCALE);

        // Failed to load media...
        if(!GrayImage)
        @{
            // Alert...
            wxLogError(wxT("Unable to load image."));
            
            // Abort...
            return;
        @}

    // Feed into tracker...
    Frame.Tracker.Advance(pGrayImage);
    
    // Cleanup gray image...
    cvReleaseImage(&GrayImage);
@}
@end example
@sp 1

Stripped:
@example
// Analyze single image...

    // Variables...

    // Reset the tracker, if not already...

    // Load the image...

        // Failed to load media...

            // Alert...

            // Abort...

    // Feed into tracker...
    
    // Cleanup gray image...
@end example
@sp 1

@item
A single blank line should appear between each pair of functions or methods. 
@sp 1

@item
Do not use a blank line after an opening brace or before a closing brace.
@sp 1

@item
Do not use duplicate blank lines.
@sp 1
@end itemize

@node Developer Tools
@subsection Developer Tools
You are welcome to use any editor or IDE you like, provided it does not require non-standard IDE-specific project files. @xref{Dependent Technology Developer Tools} for a list of all of the developer tools that are required for the project.
@sp 1

@c AresEngine architectural design...
@node Architecture
@section Architecture

The @i{AresEngine} is responsible for delivering Avaneya. It is designed by the Avaneya crew to provide for the game, but kept architecturally general enough to lend itself to other projects of similar technical requirements (e.g. a city builder / real time strategy genre). If you do not know what a game engine is, Jason Gregory's book @i{Game Engine Programming},@footnote{@xref{Resources for Engineers} for details.} is highly recommended.

The AresEngine is divided up into many subsystems, each responsible for a given logical task. These include audio, responding to input devices, updating the graphical user interface, artificial intelligence, and so on.

Umbrello was used to come up with the architectural design. At this time, you may need to use the latest Umbrello built from source because the task at hand was so demanding, only Umbrello's bleeding edge was able to handle it. Unfortunately the pre-compiled binary available in most distributions had many show stopper bugs in it that would have have made work impossible. Even building from source, it still has many problems. Nevertheless, it was the most mature and functional free design tool available at the time and may still be. We are very grateful to the Umbrello crew who were especially helpful in fixing bugs as they were discovered through the engine design stress testing it.

The following architectural diagrams were pulled from the AresEngine's Umbrello project file automatically at the time this handbook was compiled on @value{VERSION_MANUAL}.
@sp 1

@c Artificial intelligence subsection...
@page
@node Artificial Intelligence
@subsection Artificial Intelligence
This diagram concerns itself with useful artificial intelligence algorithms, though not of an entire subsystem itself.

It contains an implementation of the A* search strategy algorithm.@footnote{See @i{Computational Intelligence: A Logical Approach}, Poole et al., 1998 for an explanation on the algorithm.} The problem here is represented as a pattern for an abstract base class called @i{AStarBase}. The @i{h(x)} heuristic function is implemented via an override a context specific superclass. The abstract base class is deliberately kept general so as to not be limited to searching for a solution in a spatial sense, but in any representable solution space (e.g. time, language, etc.).
@sp 1
@image{"AresEngine/Artificial Intelligence", 6in}

@c Audio subsection...
@page
@node Audio
@subsection Audio
The @i{AudioManager} subsystem is responsible for all tasks related to audio. Audio playback is divided into streaming and static audio sources. Streaming sources need to be continuously updated by loading new data from disk, decompressing it, and playing it. A common example would be music or narrative. Static sources are usually smaller and only need to played once before being freed. Static source examples would be things like the sound of an object contacting another.

Decoding is done through an appropriate subclass of an @i{Ares::AudioDecoderBase} abstract class, instantiated via the @i{Ares::AudioDecoderFactory} class. Most decoding is done through a subclass of the aforementioned via @i{SDL_audio}.

Playback is accomplished through OpenAL.
@sp 1
@image{"AresEngine/Audio", 6in}

@c Configuration subsection...
@page
@node Configuration
@subsection Configuration
The @i{ConfigurationManager} subsystem is responsible for storing all user configuration. Its @i{Load()} method reads all configuration variables from disk, and then adds variables from command line as well, in that order. 

Latter configuration variables read are set as non-archivable. A non-archivable configuration variable is one that is not saved to disk.

Much of the manager is implemented in Lua because of its excellent database handling.
@sp 1
@image{"AresEngine/Configuration", 6in}

@c Console subsection...
@page
@node Console
@subsection Console
The in game console allows users to access aspects of the game engine at runtime. This is useful for debugging or other purposes.

Console commands are implemented in Lua.
@sp 1
@image{"AresEngine/Console", 6in}

@c Design patterns subsection...
@page
@node Design Patterns
@subsection Design Patterns
This diagram contains a number of common place design patterns found in many software projects, such as the singleton and multi-factory. 

There seems to be two kinds of singleton design patterns in the literature that are not distinguished, but should be. There is the kind whose instantiation is implicit, meaning you don't care when it is created, just as long as it is there when you need it and that there is only at most one of them ever at a given time. We refer to this as the @i{implicit singleton} and it typically uses lazy instantiation.

The second kind, like the first, only ever has one instance, but you control when you want it instantiated and deconstructed explicitly. We refer to this as the @i{explicit singleton}. This is useful for engine subsystems since C++ does not define the order in which constructors for global objects are invoked across translation units. This is important to consider, given that the order of subsystem initialization is very important (e.g. resource management must precede audio management).
@sp 1
@image{"AresEngine/Design Patterns", 6in}

@c Engine subsection...
@page
@node Engine
@subsection Engine
This diagram captures the engine at the highest level and provides an overview of all components in the most abstract sense.
@sp 1
@image{"AresEngine/Engine", 6in}

@c subsection...
@page 
@node Events
@subsection Events
The @i{EventManager} is responsible for intercommunication between various engine components and scripts. The steps for working with events are as follows.

An event handler can either contain an @i{Ares::EventHandler} class, or can derive from it and override the @i{OnEvent()} method. It registers interest in one or more events via the @i{Register()} method:
@sp 1

@example
EventHandler::Register("some_event");
@end example
@sp 1

Next, to create and enqueue an event, one would do as follows:
@sp 1

@example
// Create a some_event event...
Ares::Event SomeEvent("some_event");

// Enqueue event...
Ares::EventManager::GetSingleton().Enqueue(SomeEvent);
@end example
@sp 1

Every frame, the @i{EventManager::DispatchEvents()} method is called to pump the message queue. It will get an event from the internal priority queue that is due for processing. Once an event is fetched, it calls @i{Event.Dispatch()} to pass it to all registered handlers so that they may do whatever it is that they would like to do when that event occurs.

Events.xsd defines the XML schema that the engine uses at runtime to check builtin event types (Events.xml) against. This is done to ensure the event types defined are syntactically correct and self documenting.

Events.xml contains a list of built-in event types, game engine mod agnostic, for fundamental event types. These include things like input device and window manager events.
@sp 1
@image{"AresEngine/Events", 6in}

@c subsection...
@page 
@node File System
@subsection File System
Accessing files on disk for textures, shaders, scripts, models, sounds, and so on, requires an intermediary in most game engines. The AresEngine is no different. Files are stored inside of an EBML encoded container format called an AresPackage. The EBML format was selected because it enables extendability for future format changes and allows arbitrary metadata. It also has performance advantages because only a single file (*.AresPackage) needs to be located for a group of files contained within. This reduces file seek and access times. Also, because the AresPackage files can be compressed, it means that they take less time to access their payload because transferring a small file from disk and decompressing in RAM is faster than transferring a large uncompressed file from disk to RAM.
            
@sp 1
@image{"AresEngine/File System", 6in}

@c subsection...
@page 
@node Gooey
@subsection Gooey
The @i{GooeyManager} is responsible for managing all graphical user interface overlays and user interaction with them. Its underlying functionality is provided by CEGUI which integrates well into OGRE 3D.

@i{GooeyManager::Initialize()} calls @i{CEGUI::OgreRenderer::bootstrapSystem()}. This bootstraps @i{CEGUI::System} with an @i{OgreRenderer} object that uses the default Ogre rendering window as the default output surface, an Ogre based @i{ResourceProvider}, and an Ogre based @i{ImageCodec}.

@i{Update()} is called every frame, but we do not need to call @i{System::renderGUI()} since Ogre does this automatically. We do, however, need to call @i{CEGUI::System::injectTimePulse()} within there.

@i{Shutdown()} calls @i{CEGUI::OgreRenderer::destroySystem()}.

Most of the interesting interfaces are within CEGUI singletons themselves, with appropriate accessors and mutators exported to Lua.
@sp 1
@image{"AresEngine/Gooey", 6in}

@c subsection...
@page 
@node Human Interface
@subsection Human Interface
The @i{HumanInterfaceManager} takes care of routing all events from input devices to the appropriate code that has registered to be notified of that event. In that sense, the manager is mostly unidirectional, but also allows to send information the other way back to the input device if it supports a haptic interface (sometimes called force feedback).

@sp 1
@image{"AresEngine/Human Interface", 6in}

@c subsection...
@page 
@node Logging & Error Control
@subsection Logging & Error Control
The @i{LogManager} is responsible for providing a central logging subsystem for all the other subsystems.
@sp 1
@image{"AresEngine/Logging and Error Control", 6in}
@sp 1
Since message can be emitted from any number of places, such as within the engine, or within some other externally linked component, such as CEGUI or OGRE, messages have to be intercepted and channeled through the @i{LogManager}. The following diagram makes this more clear.
@sp 1
@image{"AresEngine/Logging State Diagram", 6in}
@sp 1

@c subsection...
@page 
@node Mathematical
@subsection Mathematical
Most mathematical routines for matrices and other linear algebra are provided by OGRE 3D. Some things like more advanced random number generation have to be implemented ourselves here.

@sp 1
@image{"AresEngine/Mathematical", 6in}

@c subsection...
@page 
@node Miscellaneous
@subsection Miscellaneous
This is a catch-all for classes and functions that had no business elsewhere.
@sp 1
@image{"AresEngine/Miscellaneous", 6in}

@c subsection...
@page 
@node Physics
@subsection Physics
The @i{PhysicsManager} needs to be seriously refactored since @i{OgreBullet} was found as a viable option for physics support. This is the original, incomplete, design before that decision was made.
@sp 1
@image{"AresEngine/Physics", 6in}

@c subsection...
@page 
@node Resources
@subsection Resources
The @i{ResourceManager} is responsible for ensuring that whenever code needs a piece of game data, such as a model or animation, all of its requisites are loaded, in the correct order, only once, and take up only as much room as they absolutely must. The @i{ResourceManager} and the @i{FileManager} communicate to help the former locate what it needs physically on disk.
@sp 1
@image{"AresEngine/Resources", 6in}

@c subsection...
@page 
@node Scripting
@subsection Scripting
The @i{ScriptManager} is responsible for exposing all useful aspects of the game engine to the game scripters. Since the engine itself is defined in code, the role of defining what makes Avaneya, Avaneya, is left to script writers.
@sp 1
@image{"AresEngine/Scripting", 6in}

