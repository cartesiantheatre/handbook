% Selected Technology chapter...
\startchapter{Selected Technology}
It is generally a bad engineering practise to re-invent the wheel by creating something in a vacuum when there are already many usable components. Avaneya's dependent technology is examined here, grouped by category. It is sometimes explained in their maintainer's own words.

We always try to stick to using free software whenever possible. The only time we might use a non-free tool is to use it as a model in designing a suitable replacement. Another time would be where writing a replacement would be far too difficult and we have no choice.

% Audio section...
\startsection{Audio}
@sp 1

\itemize
\item
We use @i{libmikmod} for playback of tracker music modules. Some people were requesting tracker support, and since it should not take very much effort to integrate into the engine's @i{AudioManager} subsystem, it seems reasonable. The library also needs to be built thread safe.
@sp 1

\item
@i{OpenAL} is used for 3D spatial audio rendering. Actual decoding of audio data is done through other APIs.
@sp 1

\item
The @i{SDL} library is used to provide audio decoding through its @i{SDL_audio} API. It decodes popular formats like Ogg Vorbis.
@sp 1
@end itemize

% Developer tools section...
\startsection{Developer Tools}
@sp 1

\itemize
\item
The @i{CppUnit} library is a unit testing framework module for the C++ programming language, used only when the engine is built in debug mode.
@sp 1

\item
The @i{GNU Autotools} are used to reconcile and harmonize the idiosyncrasies of different platforms. It makes portability far more straightforward than without it.
@sp 1

\item
The @i{GNU Compiler Collection} is used for the engine's dependency calculation, compilation, and linking, among other things. Ports of virtually all of its compilers are available everywhere.
@sp 1

\item
The @i{libebml} library is the backbone of the Matroska multimedia container format. EBML stands for @i{Extensible Binary Meta Language}. It is often thought of as a binary analogue to the XML format, though not a complete analogue because, unlike XML, the schema must be known in advance. Therefore, it is ideally suited to be read and written by machines and not humans. @xref{AresPackages} for details on how we are using it in this project.
@sp 1

\item
The @i{streflop} library (@i{STandalone REproducible FLOating-Point}) allows you to control how floating point computations are done in C++. The goal is to make programs give reliable and reproducible results. This is important because differences in machine generated code, numeric handling libraries, dedicated hardware floating point processors, optimizations, and so on, can yield results that are inconsistent across different environments.
@sp 1

\item
The @i{xmlstarlet} tool is used to validate XML against a schema. It is useful to check AresPackage manifests and the engine event definition for syntactical errors.
@sp 1
@end itemize


% Documentation and Localization section...
\startsection{Documentation & Localization}

\itemize
\item
@i{ConTeXt} is for typesetting documents, such as this one.
@sp 1

\item
@i{GNU gettext} is used for localization and translation to different human languages by making it possible to substitute strings that are marked for translation in our C++ code with a string from another language.
@sp 1
@end itemize

% Graphics section...
\startsection{Graphics}

\itemize
\item
All modelling is generally done with @i{Blender}, but modellers are free to use whatever free modelling application they like, as long as it supports common free formats. One popular alternative is @i{Wings 3D}. Ultimately though, all models have to importable into Blender since we are dependent on the OGRE 3D exporter for it in order to integrate with the rendering engine.
@sp 1

\item
@i{Caelum} is a weather generation plugin for the OGRE 3D rendering engine. It is used to provide weather effects wherever necessary on Mars.
@sp 1

\item
The @i{CEGUI} library allows graphical user interfaces to be built on top of the @i{OGRE 3D} rendering engine. This is necessary for the in game graphical user interface. CEGUI user interfaces are defined through Lua scripts accessing its Lua interface.
@sp 1

\item
@i{Hydrax} is a fluid dynamics plugin for the OGRE 3D rendering engine. It is used to provide fluid effects wherever necessary on Mars.
@sp 1

\item
The @i{OGRE 3D} rendering engine is a powerful, cross-platform, API generally aimed at game developers. It has a rich and simple to use API with a plethora of plugins available for it. It is strictly a rendering engine and does not, however, cover input, audio, and other standard game engine subsystems.
@sp 1

\item
The @i{OpenGL} library provides the rendering backend for the OGRE 3D rendering engine. Although the latter supports other backends, it is very difficult to write and maintain shaders for all of them. OpenGL is ubiquitous these days, can do virtually everything Direct3D can, and does not hold you hostage to any specific platform.
@sp 1

\item
The @i{OpenGL Extension Wrangler Library} library (@i{GLEW}, helps in querying and loading OpenGL extensions. It provides efficient run-time mechanisms for determining which OpenGL extensions are supported on the target platform. All supported OpenGL extensions are exposed in a single header file, which is machine-generated from the official extension list.
@sp 1

\item
@i{Terrain} is another plugin for the OGRE 3D rendering engine allowing for, as the name suggests, terrain generation.
@sp 1

\item
The @i{SDL} library is used to provide image and font loading through its @i{SDL_image} and @i{SDL_pango} APIs respectively.
@end itemize

% Input section...
\startsection{Input}

\itemize
\item
The @i{SDL_haptic} API is used for providing force feedback, provided the API is available and the user's input device supports it. SDL version 1.3 or greater is required.
@sp 1

\item
The @i{SDL_input} API is used to provide input handling.
@sp 1
@end itemize

% Networking section...
\startsection{Networking}

\itemize
\item
The @i{ENet} library provides the low level library which Avaneya's mutliplayer protocol is built upon. Its purpose is to provide a relatively thin, simple and robust network communication layer on top of UDP (User Datagram Protocol). The primary feature it provides is optional reliable, in-order delivery of packets. It omits certain higher level networking features such as authentication, lobbying, server discovery, encryption (which we provide via GnuTLS), or other similar tasks that are particularly application specific so that the library remains flexible, portable, and easily embeddable.
@sp 1

\item
The @i{GNU Transport Layer Security Library} (GnuTLS) is a free software implementation of the SSL and TLS protocols. It is used to provide encryption at the application level to make it more difficult for an uninvited third party to be a nuisance.
@end itemize

% Operating System section...
\startsection{Operating System}
@sp 1

\itemize
\item
@i{Apport} intercepts program crashes, collects debugging information about the crash and the operating system environment, and sends it to us in a standardized format by integrating directly into Launchpad. It is available only on supported GNU operating systems.
@sp 1

\item
The @i{D-Bus} (Desktop Bus) API is a simple inter-process communication (IPC) system for software applications to communicate with one another. Avaneya can use it to determine the state of the user's network connection, among other things. It is available only under supported POSIX compliant operating systems.
@sp 1
@end itemize

% Physics section...
\startsection{Physics}
@sp 1

\itemize
\item
@i{OgreBullet} is a plugin adding physics support to the OGRE 3D rendering engine. It is built upon @i{Bullet}, a free physics engine featuring 3D collision detection, soft body dynamics, and rigid body dynamics. It is used in games, and in visual effects in movies.
@end itemize


% Scripting section...
\startsection{Scripting}
@sp 1

\itemize

\item
The @i{libtolua++} library is used to integrate our C++ code with Lua. It is an updated replacement to the older toLua tool. It makes it possible for engine code to invoke Lua code, and vise versa.
@sp 1

\item
@i{Lua} is used to provide scripting support to the AresEngine. The runtime environment needs to have @i{package.loadlib} present.
@sp 1

\item
The @i{lua-gettext} API is a Lua package that acts as a Lua wrapper for gettext bindings.
@sp 1

\item
The @i{lua-xgettext} tool is a small program for message extraction of marked strings from Lua code so they can be made available for translation to other languages. It is similar to @i{GNU xgettext}, but far more primitive; it just extracts the strings and prints them out, without any additional information. It was written, because GNU `xgettext` did not support Lua at the time.
@end itemize


