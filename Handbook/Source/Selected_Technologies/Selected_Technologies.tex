% This is part of the Avaneya Project Crew Handbook.
% Copyright (C) 2010, 2011, 2012
%   Kshatra Corp.
% See the file License for copying conditions.

% Selected Technologies chapter...
\StartChapter{Selected Technologies}

It is generally a bad engineering practise to re-invent the wheel by creating something in a vacuum when there are already many usable components. Avaneya's dependent technology is examined here, grouped by category. It is sometimes explained in their maintainer's own words.

We always try to stick to using free software whenever possible. The only time we might use a non-free tool is to use it as a model in designing a suitable replacement. Another time would be where writing a replacement would be far too difficult and we have no choice.

Note that not all of these technologies necessarily form components of the AresEngine itself, such as Audacity and GIMP, but may be used in preparing game media for the engine.

% Audio section...
\StartSection{Audio}

\startitemize[4]
\setupwhitespace[big]
\head {\em Audacity}

We use Audacity for audio recording, editing, post-processing, effects, and more. It can take advantage of any of the multitude of LADSPA and VST plugins. It can also export to surround sound formats, such as AC3 and DTS.

\head {\em libmikmod}

We use libmikmod for playback of tracker music modules. Some people were requesting tracker support, and since it should not take very much effort to integrate into the engine's {\about[AudioManager]} subsystem, it seems reasonable. The library also needs to be built thread safe.

\head {\em OpenAL}

OpenAL is used for 3D spatial audio rendering. Actual decoding of audio data is done through other APIs.

\head {\em SDL_audio}

The SDL library is used to provide audio decoding through its SDL_audio API. It decodes popular formats like Ogg Vorbis. Since we are dependent on some features that are bleeding edge, like haptic support, we require SDL 1.3. Since it is unlikely that any distributions carry it at present, we may have to provide Ubuntu packages.
\stopitemize

% Developer tools section...
\StartSection{Developer Tools}

\startitemize[4]
\setupwhitespace[big]
\head {\em CppUnit}

The CppUnit library is a unit testing framework module for the C++ programming language, used only when the engine is built in debug mode.

\head {\em GNU Autotools}

The GNU Autotools are used to reconcile and harmonize the idiosyncrasies of different platforms. It makes portability far more straightforward than without it.

\head {\em GNU Compiler Collection}

The GNU Compiler Collection is used for the engine's dependency calculation, compilation, and linking, among other things. Ports of virtually all of its compilers are available everywhere.

\head {\em libebml}

The libebml library is the backbone of the Matroska multimedia container format. EBML stands for {\it Extensible Binary Meta Language}. It is often thought of as a binary analogue to the XML format, though not a complete analogue because, unlike XML, the schema must be known in advance. Therefore, it is ideally suited to be read and written by machines and not humans. See \in{section}[AresPackages] for details on how we are using it in this project.
item
\head {\em streflop}

The streflop library ({\it STandalone REproducible FLOating-Point}) allows you to control how floating point computations are done in C++. The goal is to make programs give reliable and reproducible results. This is important because differences in machine generated code, numeric handling libraries, dedicated hardware floating point processors, optimizations, and so on, can yield results that are inconsistent across different environments.

\head {\em xmlstarlet}

The xmlstarlet tool is used to validate XML against a schema. It is useful to check AresPackage manifests and the engine event definition for syntactical errors.

\head {\em Umbrello}

Umbrello is a powerful diagramming tool which lends itself well to the creation of UML modelling. The AresEngine's architectural design was modelled in Umbrello as seen in \in{section}[Architecture]. The two projects compliment each other well since modelling the AresEngine put very heavy demands on Umbrello, thus allowing the stress testing to identify, solve, and enhance many aspects of Umbrello. We are very grateful to the very cooperative developers working on the Umbrello project.
\stopitemize


% Documentation section...
\StartSection{Documentation}

\startitemize[4]
\setupwhitespace[big]
\head {\em \CONTEXT}

\CONTEXT\ is used for typesetting documents, such as this one. This document was compiled on \currentdate\ from Bazaar revision \BazaarRevision, typeset using \CONTEXT\ \contextversion, and rendered with \texenginename\ \texengineversion.

\head {\em Graphviz}

Graphviz is a powerful tool for drawing graphs specified in the DOT language. Graphviz's {\tt dot} was used for several of ours, such as \in{figure}[figure:Resources_Pipeline] on \at{page}[figure:Resources_Pipeline]. We used \GraphvizVersion.
\stopitemize

% Graphics section...
\StartSection{Graphics}

\startitemize[4]
\setupwhitespace[big]
\head {\em Blender}

All modelling is generally done with Blender, but modellers are free to use whatever free modelling application they like, as long as it supports common free formats. One popular alternative is {\it Wings 3D}. Ultimately though, all models have to importable into Blender since we are dependent on the OGRE 3D\index{OGRE 3D} exporter for it in order to integrate with the rendering engine.

\head {\em Caelum}

Caelum is a weather generation plugin for the OGRE 3D rendering engine. It is used to provide weather effects wherever necessary on Mars.

\head {\em Crazy Eddie's Graphical User Interface}

The Crazy Eddie's Graphical User Interface (CEGUI) library allows graphical user interfaces to be built on top of the OGRE 3D rendering engine. This is necessary for the in game graphical user interface. CEGUI user interfaces are defined through Lua scripts accessing its Lua interface.

\head {\em Hydrax}

Hydrax is a fluid dynamics plugin for the OGRE 3D rendering engine. It is used to provide fluid effects wherever necessary on Mars.

\head {\em OGRE 3D}

The {\it OGRE 3D} rendering engine is a powerful, cross-platform, API generally aimed at game developers. It has a rich and simple to use API with a plethora of plugins available for it. It is strictly a rendering engine and does not, however, cover input, audio, and other standard game engine subsystems.

\head {\em OpenGL}

The OpenGL library provides the rendering backend for the OGRE 3D rendering engine. Although the latter supports other backends, it is very difficult to write and maintain shaders for all of them. OpenGL is ubiquitous these days, can do virtually everything Direct3D can, and does not hold you hostage to any specific platform.

\head {\em OpenGL Extension Wrangler Library}

The OpenGL Extension Wrangler Library library ({\it GLEW}, helps in querying and loading OpenGL extensions. It provides efficient run-time mechanisms for determining which OpenGL extensions are supported on the target platform. All supported OpenGL extensions are exposed in a single header file, which is machine-generated from the official extension list.

\head {\em Terrain}

Terrain is another plugin for the OGRE 3D rendering engine allowing for, as the name suggests, terrain generation.

\head {\em SDL}

The SDL library is used to provide image and font loading through its SDL_image and SDL_pango APIs respectively.
\stopitemize

% Input section...
\StartSection{Input}

\startitemize[4]
\setupwhitespace[big]
\head {\em SDL_haptic}

The SDL_haptic API is used for providing force feedback, provided the API is available and the user's input device supports it. SDL version 1.3 or greater is required.

\head {\em SDL_input}

The SDL_input API is used to provide input handling.
\stopitemize

% Localization section...
\StartSection{Localization}

\startitemize[4]
\setupwhitespace[big]
\head {\em GNU gettext}

GNU gettext is used for localization and translation to different human languages by making it possible to substitute strings that are marked for translation in our C++ code with a string from another language.

\head {\em lua-gettext}

The lua-gettext API is a Lua package that acts as a Lua wrapper for gettext bindings.

\head {\em lua-xgettext}

The lua-xgettext tool is a small program for message extraction of marked strings from Lua code so they can be made available for translation to other languages. It is similar to GNU xgettext, but far more primitive; it just extracts the strings and prints them out without any additional information. It was written because GNU `xgettext` did not support Lua at the time it was created.
\stopitemize

% Networking section...
\StartSection{Networking}

\startitemize[4]
\setupwhitespace[big]
\head {\em ENet}

ENet provides the low level library which Avaneya's mutliplayer protocol is built upon. Its purpose is to provide a relatively thin, simple and robust network communication layer on top of UDP (User Datagram Protocol). The primary feature it provides is optional reliable, in-order delivery of packets. It omits certain higher level networking features such as authentication, lobbying, server discovery, encryption (which we provide via GnuTLS), or other similar tasks that are particularly application specific so that the library remains flexible, portable, and easily embeddable.

\head {\em GNU Transport Layer Security Library}

The GNU Transport Layer Security Library (GnuTLS) is a free software implementation of the SSL and TLS protocols. It is used to provide encryption at the application level to make it more difficult for an uninvited third party to be a nuisance.
\stopitemize

% Operating System section...
\StartSection{Operating System}

\startitemize[4]
\setupwhitespace[big]
\head {\em Apport}

Apport intercepts program crashes, collects debugging information about the crash and the operating system environment, and sends it to us in a standardized format by integrating directly into Launchpad. It is available only on supported GNU operating systems.

\head {\em D-Bus}

The D-Bus (Desktop Bus) API is a simple inter-process communication (IPC) system for software applications to communicate with one another. Avaneya can use it to determine the state of the user's network connection, among other things. It is available only under supported POSIX compliant operating systems.
\stopitemize

% Physics section...
\StartSection{Physics}

\startitemize[4]
\setupwhitespace[big]
\head {\em OgreBullet}

OgreBullet is a plugin that augments the OGRE 3D rendering engine with powerful physics capabilities. It is an interface to the underlying free {\it Bullet} physics engine which features 3D collision detection, soft body dynamics, and rigid body dynamics. It is used in many games and for providing visual effects in movies. 

The underlying physics engine can also leverage the user's available hardware acceleration whenever CUDA (Compute Unified Device Architecture) functionality is present, allowing the offloading of resource demanding physics calculations to specialized hardware and freeing the main CPU for other tasks. This is the case with all modern off the shelf nVidia graphics cards.
\stopitemize


% Scripting section...
\StartSection{Scripting}

\startitemize[4]
\setupwhitespace[big]
\head {\em libtolua++}

The libtolua++ library is used to integrate our C++ code with Lua. It is an updated replacement to the older toLua tool. It makes it possible for engine code to invoke Lua code, and vise versa.

\head {\em Lua}

Lua is used to provide scripting support to the AresEngine. The runtime environment needs to have {\tt package.loadlib} present.
\stopitemize

\StopChapter

